// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jj/go/pkg/mod/fyne.io/fyne/v2@v2.6.1/internal/driver/glfw/menu_darwin.go:1:1
//go:build darwin && !no_native_menus

package glfw; import _cgo_unsafe "unsafe"

import (
	"bytes"
	"fmt"
	"image/color"
	"image/png"
	"strings"
	"unsafe"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/internal/painter"
	"fyne.io/fyne/v2/internal/svg"
	"fyne.io/fyne/v2/theme"
)

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Foundation -framework AppKit

#include <AppKit/AppKit.h>

// Using void* as type for pointers is a workaround. See https://github.com/golang/go/issues/12065.
void        assignDarwinSubmenu(const void*, const void*);
void        completeDarwinMenu(void* menu, bool prepend);
const void* createDarwinMenu(const char* label);
const void* darwinAppMenu();
void        getTextColorRGBA(int* r, int* g, int* b, int* a);
const void* insertDarwinMenuItem(const void* menu, const char* label, const char* keyEquivalent, unsigned int keyEquivalentModifierMask, int id, int index, bool isSeparator, const void *imageData, unsigned int imageDataLength);
int         menuFontSize();
void        resetDarwinMenu();

// Used for tests.
const void*   test_darwinMainMenu();
const void*   test_NSMenu_itemAtIndex(const void*, NSInteger);
NSInteger     test_NSMenu_numberOfItems(const void*);
void          test_NSMenu_performActionForItemAtIndex(const void*, NSInteger);
void          test_NSMenu_removeItemAtIndex(const void* m, NSInteger i);
const char*   test_NSMenu_title(const void*);
bool          test_NSMenuItem_isSeparatorItem(const void*);
const char*   test_NSMenuItem_keyEquivalent(const void*);
unsigned long test_NSMenuItem_keyEquivalentModifierMask(const void*);
const void*   test_NSMenuItem_submenu(const void*);
const char*   test_NSMenuItem_title(const void*);
*/
import _ "unsafe"

type menuCallbacks struct {
	action  func()
	enabled func() bool
	checked func() bool
}

var callbacks []*menuCallbacks
var ecb func(string)
var specialKeys = map[fyne.KeyName]string{
	fyne.KeyBackspace: "\x08",
	fyne.KeyDelete:    "\x7f",
	fyne.KeyDown:      "\uf701",
	fyne.KeyEnd:       "\uf72b",
	fyne.KeyEnter:     "\x03",
	fyne.KeyEscape:    "\x1b",
	fyne.KeyF10:       "\uf70d",
	fyne.KeyF11:       "\uf70e",
	fyne.KeyF12:       "\uf70f",
	fyne.KeyF1:        "\uf704",
	fyne.KeyF2:        "\uf705",
	fyne.KeyF3:        "\uf706",
	fyne.KeyF4:        "\uf707",
	fyne.KeyF5:        "\uf708",
	fyne.KeyF6:        "\uf709",
	fyne.KeyF7:        "\uf70a",
	fyne.KeyF8:        "\uf70b",
	fyne.KeyF9:        "\uf70c",
	fyne.KeyHome:      "\uf729",
	fyne.KeyInsert:    "\uf727",
	fyne.KeyLeft:      "\uf702",
	fyne.KeyPageDown:  "\uf72d",
	fyne.KeyPageUp:    "\uf72c",
	fyne.KeyReturn:    "\n",
	fyne.KeyRight:     "\uf703",
	fyne.KeySpace:     " ",
	fyne.KeyTab:       "\t",
	fyne.KeyUp:        "\uf700",
}

func addNativeMenu(w *window, menu *fyne.Menu, nextItemID int, prepend bool) int {
	menu, nextItemID = handleSpecialItems(w, menu, nextItemID, true)

	containsItems := false
	for _, item := range menu.Items {
		if !item.IsSeparator {
			containsItems = true
			break
		}
	}
	if !containsItems {
		return nextItemID
	}

	nsMenu, nextItemID := createNativeMenu(w, menu, nextItemID)
	func() { _cgo0 := /*line :105:23*/nsMenu; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :105:37*/(prepend); _cgoCheckPointer(_cgo0, nil); /*line :105:47*/_Cfunc_completeDarwinMenu(_cgo0, _cgo1); }()
	return nextItemID
}

func addNativeSubmenu(w *window, nsParentMenuItem unsafe.Pointer, menu *fyne.Menu, nextItemID int) int {
	nsMenu, nextItemID := createNativeMenu(w, menu, nextItemID)
	func() { _cgo0 := /*line :111:24*/nsParentMenuItem; _cgo1 := /*line :111:42*/nsMenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :111:49*/_Cfunc_assignDarwinSubmenu(_cgo0, _cgo1); }()
	return nextItemID
}

func clearNativeMenu() {
	( /*line :116:2*/_Cfunc_resetDarwinMenu /*line :116:18*/)()
}

func createNativeMenu(w *window, menu *fyne.Menu, nextItemID int) (unsafe.Pointer, int) {
	nsMenu := ( /*line :120:12*/_Cfunc_createDarwinMenu /*line :120:29*/)(( /*line :120:31*/_Cfunc_CString /*line :120:39*/)(menu.Label))
	for _, item := range menu.Items {
		nsMenuItem := insertNativeMenuItem(nsMenu, item, nextItemID, -1)
		nextItemID = registerCallback(w, item, nextItemID)
		if item.ChildMenu != nil {
			nextItemID = addNativeSubmenu(w, nsMenuItem, item.ChildMenu, nextItemID)
		}
	}
	return nsMenu, nextItemID
}

//export exceptionCallback
func exceptionCallback(e * /*line :132:27*/_Ctype_char /*line :132:33*/) {
	msg := ( /*line :133:9*/_Cfunc_GoString /*line :133:18*/)(e)
	if ecb == nil {
		panic("unhandled Obj-C exception: " + msg)
	}
	ecb(msg)
}

func handleSpecialItems(w *window, menu *fyne.Menu, nextItemID int, addSeparator bool) (*fyne.Menu, int) {
	menu = fyne.NewMenu(menu.Label, menu.Items...) // copy so we can manipulate
	for i := 0; i < len(menu.Items); i++ {
		item := menu.Items[i]
		switch item.Label {
		case "About", "Settings", "Settings…", "Preferences", "Preferences…":
			items := make([]*fyne.MenuItem, 0, len(menu.Items)-1)
			items = append(items, menu.Items[:i]...)
			items = append(items, menu.Items[i+1:]...)
			menu, nextItemID = handleSpecialItems(w, fyne.NewMenu(menu.Label, items...), nextItemID, false)
			i--

			insertNativeMenuItem(( /*line :152:25*/_Cfunc_darwinAppMenu /*line :152:39*/)(), item, nextItemID, 1)
			if addSeparator && item.Label != "About" {
				func() _cgo_unsafe.Pointer{ _cgo0 := _Cfunc_darwinAppMenu /*line :155:21*/(); var _cgo1 *_Ctype_char = _Cfunc_CString /*line :156:15*/(""); var _cgo2 *_Ctype_char = _Cfunc_CString /*line :157:15*/(""); var _cgo3 _Ctype_uint = _Ctype_uint /*line :158:12*/(0); var _cgo4 _Ctype_int = _Ctype_int /*line :159:11*/(nextItemID); var _cgo5 _Ctype_int = _Ctype_int /*line :160:11*/(1); var _cgo6 _Ctype__Bool = _Ctype_bool /*line :161:12*/(true); _cgo7 := /*line :162:6*/unsafe.Pointer(nil); var _cgo8 _Ctype_uint = _Ctype_uint /*line :163:12*/(0); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo7, nil); return /*line :164:6*/_Cfunc_insertDarwinMenuItem(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8); }()
			}
			nextItemID = registerCallback(w, item, nextItemID)
		}
	}
	return menu, nextItemID
}

// TODO: theme change support, see NSSystemColorsDidChangeNotification
func insertNativeMenuItem(nsMenu unsafe.Pointer, item *fyne.MenuItem, nextItemID, index int) unsafe.Pointer {
	var imgData unsafe.Pointer
	var imgDataLength uint
	if item.Icon != nil {
		if svg.IsResourceSVG(item.Icon) {
			rsc := item.Icon
			if _, isThemed := rsc.(*theme.ThemedResource); isThemed {
				var r, g, b, a  /*line :180:20*/_Ctype_int /*line :180:25*/
				( /*line :181:5*/_Cfunc_getTextColorRGBA /*line :181:22*/)(&r, &g, &b, &a)
				content, err := svg.Colorize(rsc.Content(), color.NRGBA{R: uint8(r), G: uint8(g), B: uint8(b), A: uint8(a)})
				if err != nil {
					fyne.LogError("", err)
				}
				rsc = &fyne.StaticResource{
					StaticName:    rsc.Name(),
					StaticContent: content,
				}
			}
			size := int(( /*line :191:16*/_Cfunc_menuFontSize /*line :191:29*/)())
			img := painter.PaintImage(&canvas.Image{Resource: rsc}, nil, size, size)
			var buf bytes.Buffer
			if err := png.Encode(&buf, img); err != nil {
				fyne.LogError("failed to render menu icon", err)
			} else {
				imgData = unsafe.Pointer(&buf.Bytes()[0])
				imgDataLength = uint(buf.Len())
			}
		} else {
			imgData = unsafe.Pointer(&item.Icon.Content()[0])
			imgDataLength = uint(len(item.Icon.Content()))
		}
	}
	return func() _cgo_unsafe.Pointer{ _cgo0 := /*line :206:3*/nsMenu; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :207:12*/(item.Label); var _cgo2 *_Ctype_char = _Cfunc_CString /*line :208:12*/(keyEquivalent(item)); var _cgo3 _Ctype_uint = _Ctype_uint /*line :209:9*/(keyEquivalentModifierMask(item)); var _cgo4 _Ctype_int = _Ctype_int /*line :210:8*/(nextItemID); var _cgo5 _Ctype_int = _Ctype_int /*line :211:8*/(index); var _cgo6 _Ctype__Bool = _Ctype_bool /*line :212:9*/(item.IsSeparator); _cgo7 := /*line :213:3*/imgData; var _cgo8 _Ctype_uint = _Ctype_uint /*line :214:9*/(imgDataLength); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo7, nil); return /*line :215:3*/_Cfunc_insertDarwinMenuItem(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8); }()
}

func keyEquivalent(item *fyne.MenuItem) (key string) {
	if s, ok := item.Shortcut.(fyne.KeyboardShortcut); ok {
		if key = specialKeys[s.Key()]; key == "" {
			if len(s.Key()) > 1 {
				fyne.LogError(fmt.Sprintf("unsupported key “%s” for menu shortcut", s.Key()), nil)
			}
			key = strings.ToLower(string(s.Key()))
		}
	}
	return
}

func keyEquivalentModifierMask(item *fyne.MenuItem) (mask uint) {
	if s, ok := item.Shortcut.(fyne.KeyboardShortcut); ok {
		if (s.Mod() & fyne.KeyModifierShift) != 0 {
			mask |= 1 << 17 // NSEventModifierFlagShift
		}
		if (s.Mod() & fyne.KeyModifierAlt) != 0 {
			mask |= 1 << 19 // NSEventModifierFlagOption
		}
		if (s.Mod() & fyne.KeyModifierControl) != 0 {
			mask |= 1 << 18 // NSEventModifierFlagControl
		}
		if (s.Mod() & fyne.KeyModifierSuper) != 0 {
			mask |= 1 << 20 // NSEventModifierFlagCommand
		}
	}
	return
}

func registerCallback(w *window, item *fyne.MenuItem, nextItemID int) int {
	if !item.IsSeparator {
		callbacks = append(callbacks, &menuCallbacks{
			action: func() {
				if item.Action != nil {
					item.Action()
				}
			},
			enabled: func() bool {
				return !item.Disabled
			},
			checked: func() bool {
				return item.Checked
			},
		})
		nextItemID++
	}
	return nextItemID
}

func setExceptionCallback(cb func(string)) {
	ecb = cb
}

//export menuCallback
func menuCallback(id int) {
	callbacks[id].action()
}

//export menuEnabled
func menuEnabled(id int) bool {
	return callbacks[id].enabled()
}

//export menuChecked
func menuChecked(id int) bool {
	return callbacks[id].checked()
}

func setupNativeMenu(w *window, main *fyne.MainMenu) {
	clearNativeMenu()
	nextItemID := 0
	callbacks = []*menuCallbacks{}
	var helpMenu *fyne.Menu
	for i := len(main.Items) - 1; i >= 0; i-- {
		menu := main.Items[i]
		if menu.Label == "Help" {
			helpMenu = menu
			continue
		}
		nextItemID = addNativeMenu(w, menu, nextItemID, true)
	}
	if helpMenu != nil {
		addNativeMenu(w, helpMenu, nextItemID, false)
	}
}

//
// Test support methods
// These are needed because CGo is not supported inside test files.
//

func testDarwinMainMenu() unsafe.Pointer {
	return ( /*line :311:9*/_Cfunc_test_darwinMainMenu /*line :311:29*/)()
}

func testNSMenuItemAtIndex(m unsafe.Pointer, i int) unsafe.Pointer {
	return func() _cgo_unsafe.Pointer{ _cgo0 := /*line :315:35*/m; var _cgo1 _Ctype_NSInteger = _Ctype_long /*line :315:44*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :315:48*/_Cfunc_test_NSMenu_itemAtIndex(_cgo0, _cgo1); }()
}

func testNSMenuNumberOfItems(m unsafe.Pointer) int {
	return int(func() _Ctype_NSInteger{ _cgo0 := /*line :319:41*/m; _cgoCheckPointer(_cgo0, nil); return /*line :319:43*/_Cfunc_test_NSMenu_numberOfItems(_cgo0); }())
}

func testNSMenuPerformActionForItemAtIndex(m unsafe.Pointer, i int) {
	func() { _cgo0 := /*line :323:44*/m; var _cgo1 _Ctype_NSInteger = _Ctype_long /*line :323:53*/(i); _cgoCheckPointer(_cgo0, nil); /*line :323:57*/_Cfunc_test_NSMenu_performActionForItemAtIndex(_cgo0, _cgo1); }()
}

func testNSMenuRemoveItemAtIndex(m unsafe.Pointer, i int) {
	func() { _cgo0 := /*line :327:34*/m; var _cgo1 _Ctype_NSInteger = _Ctype_long /*line :327:43*/(i); _cgoCheckPointer(_cgo0, nil); /*line :327:47*/_Cfunc_test_NSMenu_removeItemAtIndex(_cgo0, _cgo1); }()
}

func testNSMenuTitle(m unsafe.Pointer) string {
	return ( /*line :331:9*/_Cfunc_GoString /*line :331:18*/)(func() *_Ctype_char{ _cgo0 := /*line :331:40*/m; _cgoCheckPointer(_cgo0, nil); return /*line :331:42*/_Cfunc_test_NSMenu_title(_cgo0); }())
}

func testNSMenuItemIsSeparatorItem(i unsafe.Pointer) bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :335:48*/i; _cgoCheckPointer(_cgo0, nil); return /*line :335:50*/_Cfunc_test_NSMenuItem_isSeparatorItem(_cgo0); }())
}

func testNSMenuItemKeyEquivalent(i unsafe.Pointer) string {
	return ( /*line :339:9*/_Cfunc_GoString /*line :339:18*/)(func() *_Ctype_char{ _cgo0 := /*line :339:52*/i; _cgoCheckPointer(_cgo0, nil); return /*line :339:54*/_Cfunc_test_NSMenuItem_keyEquivalent(_cgo0); }())
}

func testNSMenuItemKeyEquivalentModifierMask(i unsafe.Pointer) uint64 {
	return uint64( /*line :343:16*/_Ctype_ulong /*line :343:23*/(func() _Ctype_ulong{ _cgo0 := /*line :343:68*/i; _cgoCheckPointer(_cgo0, nil); return /*line :343:70*/_Cfunc_test_NSMenuItem_keyEquivalentModifierMask(_cgo0); }()))
}

func testNSMenuItemSubmenu(i unsafe.Pointer) unsafe.Pointer {
	return func() _cgo_unsafe.Pointer{ _cgo0 := /*line :347:35*/i; _cgoCheckPointer(_cgo0, nil); return /*line :347:37*/_Cfunc_test_NSMenuItem_submenu(_cgo0); }()
}

func testNSMenuItemTitle(i unsafe.Pointer) string {
	return ( /*line :351:9*/_Cfunc_GoString /*line :351:18*/)(func() *_Ctype_char{ _cgo0 := /*line :351:44*/i; _cgoCheckPointer(_cgo0, nil); return /*line :351:46*/_Cfunc_test_NSMenuItem_title(_cgo0); }())
}
